// Code generated by neuron/generator. DO NOT EDIT.
// This file was generated at:
// Fri, 14 Aug 2020 14:39:40 +0200

package tests

import (
	"strconv"
	"time"

	"github.com/google/uuid"
	"github.com/neuronlabs/neuron/errors"
	"github.com/neuronlabs/neuron/mapping"
	"github.com/neuronlabs/neuron/query"
)

// Neuron_Models stores all generated models in this package.
var Neuron_Models = []mapping.Model{
	&ArrayModel{},
	&Model{},
	&OmitModel{},
	&SimpleModel{},
}

// Compile time check if ArrayModel implements mapping.Model interface.
var _ mapping.Model = &ArrayModel{}

// NeuronCollectionName implements mapping.Model interface method.
// Returns the name of the collection for the 'ArrayModel'.
func (a *ArrayModel) NeuronCollectionName() string {
	return "array_models"
}

// IsPrimaryKeyZero implements mapping.Model interface method.
func (a *ArrayModel) IsPrimaryKeyZero() bool {
	return a.ID == uuid.UUID([16]byte{})
}

// GetPrimaryKeyValue implements mapping.Model interface method.
func (a *ArrayModel) GetPrimaryKeyValue() interface{} {
	return a.ID
}

// GetPrimaryKeyStringValue implements mapping.Model interface method.
func (a *ArrayModel) GetPrimaryKeyStringValue() (string, error) {
	id, err := a.ID.MarshalText()
	if err != nil {
		return "", errors.Wrapf(mapping.ErrFieldValue, "invalid primary field value: %v to parse string. Err: %v", a.ID, err)
	}
	return string(id), nil
}

// GetPrimaryKeyAddress implements mapping.Model interface method.
func (a *ArrayModel) GetPrimaryKeyAddress() interface{} {
	return &a.ID
}

// GetPrimaryKeyHashableValue implements mapping.Model interface method.
func (a *ArrayModel) GetPrimaryKeyHashableValue() interface{} {
	return a.ID
}

// GetPrimaryKeyZeroValue implements mapping.Model interface method.
func (a *ArrayModel) GetPrimaryKeyZeroValue() interface{} {
	return uuid.UUID([16]byte{})
}

// SetPrimaryKey implements mapping.Model interface method.
func (a *ArrayModel) SetPrimaryKeyValue(value interface{}) error {
	if v, ok := value.(uuid.UUID); ok {
		a.ID = v
		return nil
	} else if v, ok := value.([16]byte); ok {
		a.ID = uuid.UUID(v)
	}
	return errors.Wrapf(mapping.ErrFieldValue, "provided invalid value: '%T' for the primary field for model: '%T'",
		value, a)
}

// SetPrimaryKeyStringValue implements mapping.Model interface method.
func (a *ArrayModel) SetPrimaryKeyStringValue(value string) error {
	if err := a.ID.UnmarshalText([]byte(value)); err != nil {
		return errors.Wrapf(mapping.ErrFieldValue, "invalid primary field value: %v to parse string. Err: %v", a.ID, err)
	}
	return nil
}

// SetFrom implements FromSetter interface.
func (a *ArrayModel) SetFrom(model mapping.Model) error {
	if model == nil {
		return errors.Wrap(query.ErrInvalidInput, "provided nil model to set from")
	}
	from, ok := model.(*ArrayModel)
	if !ok {
		return errors.WrapDetf(mapping.ErrModelNotMatch, "provided model doesn't match the input: %T", model)
	}
	*a = *from
	return nil
}

// Compile time check if ArrayModel implements mapping.Fielder interface.
var _ mapping.Fielder = &ArrayModel{}

// GetFieldsAddress gets the address of provided 'field'.
func (a *ArrayModel) GetFieldsAddress(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return &a.ID, nil
	case 1: // SliceInt
		return &a.SliceInt, nil
	case 2: // SliceString
		return &a.SliceString, nil
	}
	return nil, errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field: '%s' for given model: ArrayModel'", field.Name())
}

// GetFieldZeroValue implements mapping.Fielder interface.s
func (a *ArrayModel) GetFieldZeroValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return uuid.UUID([16]byte{}), nil
	case 1: // SliceInt
		return nil, nil
	case 2: // SliceString
		return nil, nil
	default:
		return nil, errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
}

// IsFieldZero implements mapping.Fielder interface.
func (a *ArrayModel) IsFieldZero(field *mapping.StructField) (bool, error) {
	switch field.Index[0] {
	case 0: // ID
		return a.ID == uuid.UUID([16]byte{}), nil
	case 1: // SliceInt
		return len(a.SliceInt) == 0, nil
	case 2: // SliceString
		return len(a.SliceString) == 0, nil
	}
	return false, errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
}

// SetFieldZeroValue implements mapping.Fielder interface.s
func (a *ArrayModel) SetFieldZeroValue(field *mapping.StructField) error {
	switch field.Index[0] {
	case 0: // ID
		a.ID = uuid.UUID([16]byte{})
	case 1: // SliceInt
		a.SliceInt = nil
	case 2: // SliceString
		a.SliceString = nil
	default:
		return errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
	return nil
}

// GetHashableFieldValue implements mapping.Fielder interface.
func (a *ArrayModel) GetHashableFieldValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return a.ID, nil
	case 1: // SliceInt
		return a.SliceInt, nil
	case 2: // SliceString
		return a.SliceString, nil
	}
	return nil, errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field: '%s' for given model: 'ArrayModel'", field.Name())
}

// GetFieldValue implements mapping.Fielder interface.
func (a *ArrayModel) GetFieldValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return a.ID, nil
	case 1: // SliceInt
		return a.SliceInt, nil
	case 2: // SliceString
		return a.SliceString, nil
	}
	return nil, errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field: '%s' for given model: ArrayModel'", field.Name())
}

// SetFieldValue implements mapping.Fielder interface.
func (a *ArrayModel) SetFieldValue(field *mapping.StructField, value interface{}) (err error) {
	switch field.Index[0] {
	case 0: // ID
		if v, ok := value.(uuid.UUID); ok {
			a.ID = v
			return nil
		}
		if generic, ok := value.([]interface{}); ok {
			if len(generic) > 16 {
				return errors.Wrapf(mapping.ErrFieldValue, "provided too many values for the field: 'ID")
			}
			for i, item := range generic {
				if v, ok := item.(byte); ok {
					a.ID[i] = v
					continue
				}

			}
			return nil
		}
		// Checked wrapped types.
		if v, ok := value.([16]byte); ok {
			a.ID = uuid.UUID(v)
			return nil
		}
		return errors.Wrapf(mapping.ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 1: // SliceInt
		if value == nil {
			a.SliceInt = nil
			return nil
		}
		if v, ok := value.([]int); ok {
			a.SliceInt = v
			return nil
		}
		if generic, ok := value.([]interface{}); ok {
			for _, item := range generic {
				if v, ok := item.(int); ok {
					a.SliceInt = append(a.SliceInt, v)
					continue
				}
				switch v := item.(type) {
				case int64:
					a.SliceInt = append(a.SliceInt, int(v))
				case uint:
					a.SliceInt = append(a.SliceInt, int(v))
				case int32:
					a.SliceInt = append(a.SliceInt, int(v))
				case int16:
					a.SliceInt = append(a.SliceInt, int(v))
				case int8:
					a.SliceInt = append(a.SliceInt, int(v))
				case float64:
					a.SliceInt = append(a.SliceInt, int(v))
				default:
					return errors.Wrapf(mapping.ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
				}
			}
			return nil
		}
		return errors.Wrapf(mapping.ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 2: // SliceString
		if value == nil {
			a.SliceString = nil
			return nil
		}
		if v, ok := value.([]string); ok {
			a.SliceString = v
			return nil
		}
		if generic, ok := value.([]interface{}); ok {
			for _, item := range generic {
				if v, ok := item.(string); ok {
					a.SliceString = append(a.SliceString, v)
					continue
				}
				// Check alternate types for the SliceString.
				if v, ok := item.([]byte); ok {
					a.SliceString = append(a.SliceString, string(v))
					continue
				}
				return errors.Wrapf(mapping.ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
			}
			return nil
		}
		return errors.Wrapf(mapping.ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	default:
		return errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field: '%s' for the model: 'ArrayModel'", field.Name())
	}
}

// SetPrimaryKeyStringValue implements mapping.Model interface method.
func (a *ArrayModel) ParseFieldsStringValue(field *mapping.StructField, value string) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		temp := a.ID
		if err := a.ID.UnmarshalText([]byte(value)); err != nil {
			return "", errors.Wrapf(mapping.ErrFieldValue, "invalid field 'ID' value: '%v' to parse string. Err: %v", a.ID, err)
		}
		bt, err := a.ID.MarshalText()
		if err != nil {
			return "", errors.Wrapf(mapping.ErrFieldValue, "invalid field 'ID' value: '%v' to parse string. Err: %v", a.ID, err)
		}
		a.ID = temp
		return string(bt), nil
	case 1: // SliceInt
		return strconv.ParseInt(value, 10, mapping.IntegerBitSize)
	case 2: // SliceString
		return value, nil
	}
	return nil, errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field: '%s' for given model: ArrayModel'", field.Name())
}

// Compile time check if Model implements mapping.Model interface.
var _ mapping.Model = &Model{}

// NeuronCollectionName implements mapping.Model interface method.
// Returns the name of the collection for the 'Model'.
func (m *Model) NeuronCollectionName() string {
	return "models"
}

// IsPrimaryKeyZero implements mapping.Model interface method.
func (m *Model) IsPrimaryKeyZero() bool {
	return m.ID == 0
}

// GetPrimaryKeyValue implements mapping.Model interface method.
func (m *Model) GetPrimaryKeyValue() interface{} {
	return m.ID
}

// GetPrimaryKeyStringValue implements mapping.Model interface method.
func (m *Model) GetPrimaryKeyStringValue() (string, error) {
	return strconv.FormatInt(int64(m.ID), 10), nil
}

// GetPrimaryKeyAddress implements mapping.Model interface method.
func (m *Model) GetPrimaryKeyAddress() interface{} {
	return &m.ID
}

// GetPrimaryKeyHashableValue implements mapping.Model interface method.
func (m *Model) GetPrimaryKeyHashableValue() interface{} {
	return m.ID
}

// GetPrimaryKeyZeroValue implements mapping.Model interface method.
func (m *Model) GetPrimaryKeyZeroValue() interface{} {
	return 0
}

// SetPrimaryKey implements mapping.Model interface method.
func (m *Model) SetPrimaryKeyValue(value interface{}) error {
	if v, ok := value.(int); ok {
		m.ID = v
		return nil
	}
	// Check alternate types for given field.
	switch valueType := value.(type) {
	case int8:
		m.ID = int(valueType)
	case int16:
		m.ID = int(valueType)
	case int32:
		m.ID = int(valueType)
	case int64:
		m.ID = int(valueType)
	case uint:
		m.ID = int(valueType)
	case uint8:
		m.ID = int(valueType)
	case uint16:
		m.ID = int(valueType)
	case uint32:
		m.ID = int(valueType)
	case uint64:
		m.ID = int(valueType)
	case float32:
		m.ID = int(valueType)
	case float64:
		m.ID = int(valueType)
	default:
		return errors.Wrapf(mapping.ErrFieldValue, "provided invalid value: '%T' for the primary field for model: 'Model'", value)
	}
	return nil
}

// SetPrimaryKeyStringValue implements mapping.Model interface method.
func (m *Model) SetPrimaryKeyStringValue(value string) error {
	tmp, err := strconv.ParseInt(value, 10, mapping.IntegerBitSize)
	if err != nil {
		return err
	}
	m.ID = int(tmp)
	return nil
}

// SetFrom implements FromSetter interface.
func (m *Model) SetFrom(model mapping.Model) error {
	if model == nil {
		return errors.Wrap(query.ErrInvalidInput, "provided nil model to set from")
	}
	from, ok := model.(*Model)
	if !ok {
		return errors.WrapDetf(mapping.ErrModelNotMatch, "provided model doesn't match the input: %T", model)
	}
	*m = *from
	return nil
}

// Compile time check if Model implements mapping.Fielder interface.
var _ mapping.Fielder = &Model{}

// GetFieldsAddress gets the address of provided 'field'.
func (m *Model) GetFieldsAddress(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return &m.ID, nil
	case 1: // AttrString
		return &m.AttrString, nil
	case 2: // StringPtr
		return &m.StringPtr, nil
	case 3: // Int
		return &m.Int, nil
	case 4: // CreatedAt
		return &m.CreatedAt, nil
	case 5: // UpdatedAt
		return &m.UpdatedAt, nil
	case 6: // DeletedAt
		return &m.DeletedAt, nil
	}
	return nil, errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field: '%s' for given model: Model'", field.Name())
}

// GetFieldZeroValue implements mapping.Fielder interface.s
func (m *Model) GetFieldZeroValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return 0, nil
	case 1: // AttrString
		return "", nil
	case 2: // StringPtr
		return nil, nil
	case 3: // Int
		return 0, nil
	case 4: // CreatedAt
		return time.Time{}, nil
	case 5: // UpdatedAt
		return nil, nil
	case 6: // DeletedAt
		return nil, nil
	default:
		return nil, errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
}

// IsFieldZero implements mapping.Fielder interface.
func (m *Model) IsFieldZero(field *mapping.StructField) (bool, error) {
	switch field.Index[0] {
	case 0: // ID
		return m.ID == 0, nil
	case 1: // AttrString
		return m.AttrString == "", nil
	case 2: // StringPtr
		return m.StringPtr == nil, nil
	case 3: // Int
		return m.Int == 0, nil
	case 4: // CreatedAt
		return m.CreatedAt == time.Time{}, nil
	case 5: // UpdatedAt
		return m.UpdatedAt == nil, nil
	case 6: // DeletedAt
		return m.DeletedAt == nil, nil
	}
	return false, errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
}

// SetFieldZeroValue implements mapping.Fielder interface.s
func (m *Model) SetFieldZeroValue(field *mapping.StructField) error {
	switch field.Index[0] {
	case 0: // ID
		m.ID = 0
	case 1: // AttrString
		m.AttrString = ""
	case 2: // StringPtr
		m.StringPtr = nil
	case 3: // Int
		m.Int = 0
	case 4: // CreatedAt
		m.CreatedAt = time.Time{}
	case 5: // UpdatedAt
		m.UpdatedAt = nil
	case 6: // DeletedAt
		m.DeletedAt = nil
	default:
		return errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
	return nil
}

// GetHashableFieldValue implements mapping.Fielder interface.
func (m *Model) GetHashableFieldValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return m.ID, nil
	case 1: // AttrString
		return m.AttrString, nil
	case 2: // StringPtr
		if m.StringPtr == nil {
			return nil, nil
		}
		return *m.StringPtr, nil
	case 3: // Int
		return m.Int, nil
	case 4: // CreatedAt
		return m.CreatedAt, nil
	case 5: // UpdatedAt
		if m.UpdatedAt == nil {
			return nil, nil
		}
		return *m.UpdatedAt, nil
	case 6: // DeletedAt
		if m.DeletedAt == nil {
			return nil, nil
		}
		return *m.DeletedAt, nil
	}
	return nil, errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field: '%s' for given model: 'Model'", field.Name())
}

// GetFieldValue implements mapping.Fielder interface.
func (m *Model) GetFieldValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return m.ID, nil
	case 1: // AttrString
		return m.AttrString, nil
	case 2: // StringPtr
		return m.StringPtr, nil
	case 3: // Int
		return m.Int, nil
	case 4: // CreatedAt
		return m.CreatedAt, nil
	case 5: // UpdatedAt
		return m.UpdatedAt, nil
	case 6: // DeletedAt
		return m.DeletedAt, nil
	}
	return nil, errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field: '%s' for given model: Model'", field.Name())
}

// SetFieldValue implements mapping.Fielder interface.
func (m *Model) SetFieldValue(field *mapping.StructField, value interface{}) (err error) {
	switch field.Index[0] {
	case 0: // ID
		if v, ok := value.(int); ok {
			m.ID = v
			return nil
		}

		switch v := value.(type) {
		case int8:
			m.ID = int(v)
		case int16:
			m.ID = int(v)
		case int32:
			m.ID = int(v)
		case int64:
			m.ID = int(v)
		case uint:
			m.ID = int(v)
		case uint8:
			m.ID = int(v)
		case uint16:
			m.ID = int(v)
		case uint32:
			m.ID = int(v)
		case uint64:
			m.ID = int(v)
		case float32:
			m.ID = int(v)
		case float64:
			m.ID = int(v)
		default:
			return errors.Wrapf(mapping.ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	case 1: // AttrString
		if v, ok := value.(string); ok {
			m.AttrString = v
			return nil
		}

		// Check alternate types for the AttrString.
		if v, ok := value.([]byte); ok {
			m.AttrString = string(v)
			return nil
		}
		return errors.Wrapf(mapping.ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 2: // StringPtr
		if value == nil {
			m.StringPtr = nil
			return nil
		}
		if v, ok := value.(*string); ok {
			m.StringPtr = v
			return nil
		}
		// Check if it is non-pointer value.
		if v, ok := value.(string); ok {
			m.StringPtr = &v
			return nil
		}

		// Check alternate types for the StringPtr.
		if v, ok := value.([]byte); ok {
			temp := string(v)
			m.StringPtr = &temp
			return nil
		}
		return errors.Wrapf(mapping.ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 3: // Int
		if v, ok := value.(int); ok {
			m.Int = v
			return nil
		}

		switch v := value.(type) {
		case int8:
			m.Int = int(v)
		case int16:
			m.Int = int(v)
		case int32:
			m.Int = int(v)
		case int64:
			m.Int = int(v)
		case uint:
			m.Int = int(v)
		case uint8:
			m.Int = int(v)
		case uint16:
			m.Int = int(v)
		case uint32:
			m.Int = int(v)
		case uint64:
			m.Int = int(v)
		case float32:
			m.Int = int(v)
		case float64:
			m.Int = int(v)
		default:
			return errors.Wrapf(mapping.ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	case 4: // CreatedAt
		if v, ok := value.(time.Time); ok {
			m.CreatedAt = v
			return nil
		}

		return errors.Wrapf(mapping.ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 5: // UpdatedAt
		if value == nil {
			m.UpdatedAt = nil
			return nil
		}
		if v, ok := value.(*time.Time); ok {
			m.UpdatedAt = v
			return nil
		}
		// Check if it is non-pointer value.
		if v, ok := value.(time.Time); ok {
			m.UpdatedAt = &v
			return nil
		}

		return errors.Wrapf(mapping.ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 6: // DeletedAt
		if value == nil {
			m.DeletedAt = nil
			return nil
		}
		if v, ok := value.(*time.Time); ok {
			m.DeletedAt = v
			return nil
		}
		// Check if it is non-pointer value.
		if v, ok := value.(time.Time); ok {
			m.DeletedAt = &v
			return nil
		}

		return errors.Wrapf(mapping.ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	default:
		return errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field: '%s' for the model: 'Model'", field.Name())
	}
}

// SetPrimaryKeyStringValue implements mapping.Model interface method.
func (m *Model) ParseFieldsStringValue(field *mapping.StructField, value string) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return strconv.ParseInt(value, 10, mapping.IntegerBitSize)
	case 1: // AttrString
		return value, nil
	case 2: // StringPtr
		return value, nil
	case 3: // Int
		return strconv.ParseInt(value, 10, mapping.IntegerBitSize)
	case 4: // CreatedAt
		temp := m.CreatedAt
		if err := m.CreatedAt.UnmarshalText([]byte(value)); err != nil {
			return "", errors.Wrapf(mapping.ErrFieldValue, "invalid field 'CreatedAt' value: '%v' to parse string. Err: %v", m.CreatedAt, err)
		}
		bt, err := m.CreatedAt.MarshalText()
		if err != nil {
			return "", errors.Wrapf(mapping.ErrFieldValue, "invalid field 'CreatedAt' value: '%v' to parse string. Err: %v", m.CreatedAt, err)
		}
		m.CreatedAt = temp
		return string(bt), nil
	case 5: // UpdatedAt
		var base time.Time
		temp := &base
		if err := temp.UnmarshalText([]byte(value)); err != nil {
			return "", errors.Wrapf(mapping.ErrFieldValue, "invalid field 'UpdatedAt' value: '%v' to parse string. Err: %v", m.UpdatedAt, err)
		}
		bt, err := temp.MarshalText()
		if err != nil {
			return "", errors.Wrapf(mapping.ErrFieldValue, "invalid field 'UpdatedAt' value: '%v' to parse string. Err: %v", m.UpdatedAt, err)
		}

		return string(bt), nil
	case 6: // DeletedAt
		var base time.Time
		temp := &base
		if err := temp.UnmarshalText([]byte(value)); err != nil {
			return "", errors.Wrapf(mapping.ErrFieldValue, "invalid field 'DeletedAt' value: '%v' to parse string. Err: %v", m.DeletedAt, err)
		}
		bt, err := temp.MarshalText()
		if err != nil {
			return "", errors.Wrapf(mapping.ErrFieldValue, "invalid field 'DeletedAt' value: '%v' to parse string. Err: %v", m.DeletedAt, err)
		}

		return string(bt), nil
	}
	return nil, errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field: '%s' for given model: Model'", field.Name())
}

// Compile time check if OmitModel implements mapping.Model interface.
var _ mapping.Model = &OmitModel{}

// NeuronCollectionName implements mapping.Model interface method.
// Returns the name of the collection for the 'OmitModel'.
func (o *OmitModel) NeuronCollectionName() string {
	return "omit_models"
}

// IsPrimaryKeyZero implements mapping.Model interface method.
func (o *OmitModel) IsPrimaryKeyZero() bool {
	return o.ID == 0
}

// GetPrimaryKeyValue implements mapping.Model interface method.
func (o *OmitModel) GetPrimaryKeyValue() interface{} {
	return o.ID
}

// GetPrimaryKeyStringValue implements mapping.Model interface method.
func (o *OmitModel) GetPrimaryKeyStringValue() (string, error) {
	return strconv.FormatInt(int64(o.ID), 10), nil
}

// GetPrimaryKeyAddress implements mapping.Model interface method.
func (o *OmitModel) GetPrimaryKeyAddress() interface{} {
	return &o.ID
}

// GetPrimaryKeyHashableValue implements mapping.Model interface method.
func (o *OmitModel) GetPrimaryKeyHashableValue() interface{} {
	return o.ID
}

// GetPrimaryKeyZeroValue implements mapping.Model interface method.
func (o *OmitModel) GetPrimaryKeyZeroValue() interface{} {
	return 0
}

// SetPrimaryKey implements mapping.Model interface method.
func (o *OmitModel) SetPrimaryKeyValue(value interface{}) error {
	if v, ok := value.(int); ok {
		o.ID = v
		return nil
	}
	// Check alternate types for given field.
	switch valueType := value.(type) {
	case int8:
		o.ID = int(valueType)
	case int16:
		o.ID = int(valueType)
	case int32:
		o.ID = int(valueType)
	case int64:
		o.ID = int(valueType)
	case uint:
		o.ID = int(valueType)
	case uint8:
		o.ID = int(valueType)
	case uint16:
		o.ID = int(valueType)
	case uint32:
		o.ID = int(valueType)
	case uint64:
		o.ID = int(valueType)
	case float32:
		o.ID = int(valueType)
	case float64:
		o.ID = int(valueType)
	default:
		return errors.Wrapf(mapping.ErrFieldValue, "provided invalid value: '%T' for the primary field for model: 'OmitModel'", value)
	}
	return nil
}

// SetPrimaryKeyStringValue implements mapping.Model interface method.
func (o *OmitModel) SetPrimaryKeyStringValue(value string) error {
	tmp, err := strconv.ParseInt(value, 10, mapping.IntegerBitSize)
	if err != nil {
		return err
	}
	o.ID = int(tmp)
	return nil
}

// SetFrom implements FromSetter interface.
func (o *OmitModel) SetFrom(model mapping.Model) error {
	if model == nil {
		return errors.Wrap(query.ErrInvalidInput, "provided nil model to set from")
	}
	from, ok := model.(*OmitModel)
	if !ok {
		return errors.WrapDetf(mapping.ErrModelNotMatch, "provided model doesn't match the input: %T", model)
	}
	*o = *from
	return nil
}

// Compile time check if OmitModel implements mapping.Fielder interface.
var _ mapping.Fielder = &OmitModel{}

// GetFieldsAddress gets the address of provided 'field'.
func (o *OmitModel) GetFieldsAddress(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return &o.ID, nil
	case 1: // OmitField
		return &o.OmitField, nil
	}
	return nil, errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field: '%s' for given model: OmitModel'", field.Name())
}

// GetFieldZeroValue implements mapping.Fielder interface.s
func (o *OmitModel) GetFieldZeroValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return 0, nil
	case 1: // OmitField
		return "", nil
	default:
		return nil, errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
}

// IsFieldZero implements mapping.Fielder interface.
func (o *OmitModel) IsFieldZero(field *mapping.StructField) (bool, error) {
	switch field.Index[0] {
	case 0: // ID
		return o.ID == 0, nil
	case 1: // OmitField
		return o.OmitField == "", nil
	}
	return false, errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
}

// SetFieldZeroValue implements mapping.Fielder interface.s
func (o *OmitModel) SetFieldZeroValue(field *mapping.StructField) error {
	switch field.Index[0] {
	case 0: // ID
		o.ID = 0
	case 1: // OmitField
		o.OmitField = ""
	default:
		return errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
	return nil
}

// GetHashableFieldValue implements mapping.Fielder interface.
func (o *OmitModel) GetHashableFieldValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return o.ID, nil
	case 1: // OmitField
		return o.OmitField, nil
	}
	return nil, errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field: '%s' for given model: 'OmitModel'", field.Name())
}

// GetFieldValue implements mapping.Fielder interface.
func (o *OmitModel) GetFieldValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return o.ID, nil
	case 1: // OmitField
		return o.OmitField, nil
	}
	return nil, errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field: '%s' for given model: OmitModel'", field.Name())
}

// SetFieldValue implements mapping.Fielder interface.
func (o *OmitModel) SetFieldValue(field *mapping.StructField, value interface{}) (err error) {
	switch field.Index[0] {
	case 0: // ID
		if v, ok := value.(int); ok {
			o.ID = v
			return nil
		}

		switch v := value.(type) {
		case int8:
			o.ID = int(v)
		case int16:
			o.ID = int(v)
		case int32:
			o.ID = int(v)
		case int64:
			o.ID = int(v)
		case uint:
			o.ID = int(v)
		case uint8:
			o.ID = int(v)
		case uint16:
			o.ID = int(v)
		case uint32:
			o.ID = int(v)
		case uint64:
			o.ID = int(v)
		case float32:
			o.ID = int(v)
		case float64:
			o.ID = int(v)
		default:
			return errors.Wrapf(mapping.ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	case 1: // OmitField
		if v, ok := value.(string); ok {
			o.OmitField = v
			return nil
		}

		// Check alternate types for the OmitField.
		if v, ok := value.([]byte); ok {
			o.OmitField = string(v)
			return nil
		}
		return errors.Wrapf(mapping.ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	default:
		return errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field: '%s' for the model: 'OmitModel'", field.Name())
	}
}

// SetPrimaryKeyStringValue implements mapping.Model interface method.
func (o *OmitModel) ParseFieldsStringValue(field *mapping.StructField, value string) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return strconv.ParseInt(value, 10, mapping.IntegerBitSize)
	case 1: // OmitField
		return value, nil
	}
	return nil, errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field: '%s' for given model: OmitModel'", field.Name())
}

// Compile time check if SimpleModel implements mapping.Model interface.
var _ mapping.Model = &SimpleModel{}

// NeuronCollectionName implements mapping.Model interface method.
// Returns the name of the collection for the 'SimpleModel'.
func (s *SimpleModel) NeuronCollectionName() string {
	return "simple_models"
}

// IsPrimaryKeyZero implements mapping.Model interface method.
func (s *SimpleModel) IsPrimaryKeyZero() bool {
	return s.ID == 0
}

// GetPrimaryKeyValue implements mapping.Model interface method.
func (s *SimpleModel) GetPrimaryKeyValue() interface{} {
	return s.ID
}

// GetPrimaryKeyStringValue implements mapping.Model interface method.
func (s *SimpleModel) GetPrimaryKeyStringValue() (string, error) {
	return strconv.FormatInt(int64(s.ID), 10), nil
}

// GetPrimaryKeyAddress implements mapping.Model interface method.
func (s *SimpleModel) GetPrimaryKeyAddress() interface{} {
	return &s.ID
}

// GetPrimaryKeyHashableValue implements mapping.Model interface method.
func (s *SimpleModel) GetPrimaryKeyHashableValue() interface{} {
	return s.ID
}

// GetPrimaryKeyZeroValue implements mapping.Model interface method.
func (s *SimpleModel) GetPrimaryKeyZeroValue() interface{} {
	return 0
}

// SetPrimaryKey implements mapping.Model interface method.
func (s *SimpleModel) SetPrimaryKeyValue(value interface{}) error {
	if v, ok := value.(int); ok {
		s.ID = v
		return nil
	}
	// Check alternate types for given field.
	switch valueType := value.(type) {
	case int8:
		s.ID = int(valueType)
	case int16:
		s.ID = int(valueType)
	case int32:
		s.ID = int(valueType)
	case int64:
		s.ID = int(valueType)
	case uint:
		s.ID = int(valueType)
	case uint8:
		s.ID = int(valueType)
	case uint16:
		s.ID = int(valueType)
	case uint32:
		s.ID = int(valueType)
	case uint64:
		s.ID = int(valueType)
	case float32:
		s.ID = int(valueType)
	case float64:
		s.ID = int(valueType)
	default:
		return errors.Wrapf(mapping.ErrFieldValue, "provided invalid value: '%T' for the primary field for model: 'SimpleModel'", value)
	}
	return nil
}

// SetPrimaryKeyStringValue implements mapping.Model interface method.
func (s *SimpleModel) SetPrimaryKeyStringValue(value string) error {
	tmp, err := strconv.ParseInt(value, 10, mapping.IntegerBitSize)
	if err != nil {
		return err
	}
	s.ID = int(tmp)
	return nil
}

// SetFrom implements FromSetter interface.
func (s *SimpleModel) SetFrom(model mapping.Model) error {
	if model == nil {
		return errors.Wrap(query.ErrInvalidInput, "provided nil model to set from")
	}
	from, ok := model.(*SimpleModel)
	if !ok {
		return errors.WrapDetf(mapping.ErrModelNotMatch, "provided model doesn't match the input: %T", model)
	}
	*s = *from
	return nil
}

// Compile time check if SimpleModel implements mapping.Fielder interface.
var _ mapping.Fielder = &SimpleModel{}

// GetFieldsAddress gets the address of provided 'field'.
func (s *SimpleModel) GetFieldsAddress(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return &s.ID, nil
	case 1: // Attr
		return &s.Attr, nil
	case 2: // CreatedAt
		return &s.CreatedAt, nil
	}
	return nil, errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field: '%s' for given model: SimpleModel'", field.Name())
}

// GetFieldZeroValue implements mapping.Fielder interface.s
func (s *SimpleModel) GetFieldZeroValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return 0, nil
	case 1: // Attr
		return "", nil
	case 2: // CreatedAt
		return nil, nil
	default:
		return nil, errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
}

// IsFieldZero implements mapping.Fielder interface.
func (s *SimpleModel) IsFieldZero(field *mapping.StructField) (bool, error) {
	switch field.Index[0] {
	case 0: // ID
		return s.ID == 0, nil
	case 1: // Attr
		return s.Attr == "", nil
	case 2: // CreatedAt
		return s.CreatedAt == nil, nil
	}
	return false, errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
}

// SetFieldZeroValue implements mapping.Fielder interface.s
func (s *SimpleModel) SetFieldZeroValue(field *mapping.StructField) error {
	switch field.Index[0] {
	case 0: // ID
		s.ID = 0
	case 1: // Attr
		s.Attr = ""
	case 2: // CreatedAt
		s.CreatedAt = nil
	default:
		return errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
	return nil
}

// GetHashableFieldValue implements mapping.Fielder interface.
func (s *SimpleModel) GetHashableFieldValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return s.ID, nil
	case 1: // Attr
		return s.Attr, nil
	case 2: // CreatedAt
		if s.CreatedAt == nil {
			return nil, nil
		}
		return *s.CreatedAt, nil
	}
	return nil, errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field: '%s' for given model: 'SimpleModel'", field.Name())
}

// GetFieldValue implements mapping.Fielder interface.
func (s *SimpleModel) GetFieldValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return s.ID, nil
	case 1: // Attr
		return s.Attr, nil
	case 2: // CreatedAt
		return s.CreatedAt, nil
	}
	return nil, errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field: '%s' for given model: SimpleModel'", field.Name())
}

// SetFieldValue implements mapping.Fielder interface.
func (s *SimpleModel) SetFieldValue(field *mapping.StructField, value interface{}) (err error) {
	switch field.Index[0] {
	case 0: // ID
		if v, ok := value.(int); ok {
			s.ID = v
			return nil
		}

		switch v := value.(type) {
		case int8:
			s.ID = int(v)
		case int16:
			s.ID = int(v)
		case int32:
			s.ID = int(v)
		case int64:
			s.ID = int(v)
		case uint:
			s.ID = int(v)
		case uint8:
			s.ID = int(v)
		case uint16:
			s.ID = int(v)
		case uint32:
			s.ID = int(v)
		case uint64:
			s.ID = int(v)
		case float32:
			s.ID = int(v)
		case float64:
			s.ID = int(v)
		default:
			return errors.Wrapf(mapping.ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	case 1: // Attr
		if v, ok := value.(string); ok {
			s.Attr = v
			return nil
		}

		// Check alternate types for the Attr.
		if v, ok := value.([]byte); ok {
			s.Attr = string(v)
			return nil
		}
		return errors.Wrapf(mapping.ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 2: // CreatedAt
		if value == nil {
			s.CreatedAt = nil
			return nil
		}
		if v, ok := value.(*time.Time); ok {
			s.CreatedAt = v
			return nil
		}
		// Check if it is non-pointer value.
		if v, ok := value.(time.Time); ok {
			s.CreatedAt = &v
			return nil
		}

		return errors.Wrapf(mapping.ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	default:
		return errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field: '%s' for the model: 'SimpleModel'", field.Name())
	}
}

// SetPrimaryKeyStringValue implements mapping.Model interface method.
func (s *SimpleModel) ParseFieldsStringValue(field *mapping.StructField, value string) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return strconv.ParseInt(value, 10, mapping.IntegerBitSize)
	case 1: // Attr
		return value, nil
	case 2: // CreatedAt
		var base time.Time
		temp := &base
		if err := temp.UnmarshalText([]byte(value)); err != nil {
			return "", errors.Wrapf(mapping.ErrFieldValue, "invalid field 'CreatedAt' value: '%v' to parse string. Err: %v", s.CreatedAt, err)
		}
		bt, err := temp.MarshalText()
		if err != nil {
			return "", errors.Wrapf(mapping.ErrFieldValue, "invalid field 'CreatedAt' value: '%v' to parse string. Err: %v", s.CreatedAt, err)
		}

		return string(bt), nil
	}
	return nil, errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field: '%s' for given model: SimpleModel'", field.Name())
}
